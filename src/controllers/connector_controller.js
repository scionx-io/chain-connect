import { Controller } from "@hotwired/stimulus"
import { createStore } from 'mipd';
import { render } from 'uhtml';
import { WalletManager } from '../core/wallet_manager.js';
import { modalTemplate } from '../templates/modal_template.js';

export default class ConnectorController extends Controller {
  // Stimulus targets - modal auto-generates if not provided
  static targets = ["modal"]

  // Stimulus values - reactive state management
  static values = {
    address: String,
    chainId: String,
    walletName: String,
    rdns: String,
    family: String,
    isConnected: { type: Boolean, default: false },
    connecting: { type: Boolean, default: false },
    selectedRdns: String
  }

  // ============================================================================
  // Lifecycle
  // ============================================================================

  connect() {
    // Auto-generate modal if user didn't provide one
    if (!this.hasModalTarget) {
      this.createModalTarget();
    }

    // Initialize services
    this.mipdStore = createStore();
    this.walletManager = new WalletManager(this.mipdStore);

    // Set up event listeners for WalletManager events
    this.setupEventListeners();

    // Initialize wallet manager for auto-reconnect
    this.walletManager.init();

    // Initialize wallet detection
    this.initializeWalletDetection();
  }

  disconnect() {
    this.cleanupEventListeners();

    if (this.walletManager.getActiveConnection()) {
      this.walletManager.disconnect();
    }

    // Unsubscribe from MIPD store
    if (this.mipdStoreUnsubscribe) {
      this.mipdStoreUnsubscribe();
    }

    // Remove auto-generated modal
    if (this.autoGeneratedModal) {
      this.modalTarget.remove();
    }
  }

  // ============================================================================
  // Getters (for backward compatibility and programmatic access)
  // ============================================================================

  get address() {
    return this.addressValue;
  }

  get chainId() {
    return this.chainIdValue;
  }

  get provider() {
    return this.walletManager.getActiveConnection()?.provider;
  }

  get isConnected() {
    return this.isConnectedValue;
  }

  // ============================================================================
  // Target Creation
  // ============================================================================

  createModalTarget() {
    const container = document.createElement('div');
    container.dataset.walletTarget = "modal";
    document.body.appendChild(container);
    this.autoGeneratedModal = true;
  }

  // ============================================================================
  // User Actions (Stimulus Actions)
  // ============================================================================

  connectWallet() {
    this.openModal();
  }

  async disconnectWallet() {
    if (this.walletManager.getActiveConnection()) {
      const rdns = this.walletManager.getActiveConnection().rdns;
      await this.walletManager.disconnect(rdns);
    }
  }

  async selectWallet(event) {
    const button = event.currentTarget;
    const rdns = button.dataset.walletRdns;

    if (!rdns) {
      this.dispatch('error', {
        detail: { message: 'Invalid wallet selection' }
      });
      return;
    }

    // Set connecting state
    this.connectingValue = true;
    this.selectedRdnsValue = rdns;

    this.closeModal();
    this.dispatch('connecting', { detail: { rdns } });

    try {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Connection timeout')), 30000);
      });

      await Promise.race([this.walletManager.connect(rdns), timeoutPromise]);
    } catch (error) {
      console.error('Wallet connection error:', error);
      this.dispatch('error', {
        detail: {
          message: error.message || 'Connection failed',
          error
        }
      });
    } finally {
      this.connectingValue = false;
      this.selectedRdnsValue = "";
    }
  }

  // ============================================================================
  // Modal Management
  // ============================================================================

  renderModal() {
    const wallets = this.walletManager.getDetectedWallets();
    render(this.modalTarget, modalTemplate(wallets));

    // Get the dialog element
    this.modal = this.modalTarget.querySelector('dialog');

    // Close on backdrop click
    if (this.modal) {
      this.modal.addEventListener('click', (e) => {
        if (e.target === this.modal) {
          this.closeModal();
        }
      });
    }
  }

  openModal() {
    this.renderModal();
    if (this.modal) {
      this.modal.showModal();
    }
  }

  closeModal() {
    if (this.modal) {
      this.modal.close();
    }
  }

  // ============================================================================
  // Wallet Detection
  // ============================================================================

  initializeWalletDetection() {
    // Render modal on first load
    this.renderModal();

    // Dispatch event for apps that want to show wallet info elsewhere
    this.dispatch('walletsDetected', {
      detail: { wallets: this.walletManager.getDetectedWallets() }
    });

    // Re-render and dispatch when new wallets inject
    this.mipdStoreUnsubscribe = this.mipdStore.subscribe(() => {
      // Update modal if it exists and is open
      if (this.modal && this.modal.open) {
        this.renderModal();
      }

      this.dispatch('walletsDetected', {
        detail: { wallets: this.walletManager.getDetectedWallets() }
      });
    });
  }

  // ============================================================================
  // Event Listener Management (WalletManager EventTarget)
  // ============================================================================

  setupEventListeners() {
    this.boundHandleConnected = this.handleConnected.bind(this);
    this.boundHandleDisconnected = this.handleDisconnected.bind(this);
    this.boundHandleChainChanged = this.handleChainChanged.bind(this);
    this.boundHandleAccountChanged = this.handleAccountChanged.bind(this);

    this.walletManager.addEventListener('connected', this.boundHandleConnected);
    this.walletManager.addEventListener('disconnected', this.boundHandleDisconnected);
    this.walletManager.addEventListener('chainChanged', this.boundHandleChainChanged);
    this.walletManager.addEventListener('accountChanged', this.boundHandleAccountChanged);
  }

  cleanupEventListeners() {
    if (this.walletManager) {
      this.walletManager.removeEventListener('connected', this.boundHandleConnected);
      this.walletManager.removeEventListener('disconnected', this.boundHandleDisconnected);
      this.walletManager.removeEventListener('chainChanged', this.boundHandleChainChanged);
      this.walletManager.removeEventListener('accountChanged', this.boundHandleAccountChanged);
    }
  }

  // ============================================================================
  // Event Handlers (from WalletManager)
  // ============================================================================

  handleConnected(event) {
    const { connection } = event.detail;

    // Update Stimulus values (triggers reactive callbacks)
    this.addressValue = connection.address;
    this.chainIdValue = connection.chainId;
    this.walletNameValue = connection.name;
    this.rdnsValue = connection.rdns;
    this.familyValue = connection.family;
    this.isConnectedValue = true;

    // Dispatch Stimulus event
    this.dispatch('connected', {
      detail: {
        address: connection.address,
        chainId: connection.chainId,
        name: connection.name,
        rdns: connection.rdns,
        family: connection.family,
        provider: connection.provider
      }
    });
  }

  handleDisconnected() {
    // Clear Stimulus values
    this.addressValue = "";
    this.chainIdValue = "";
    this.walletNameValue = "";
    this.rdnsValue = "";
    this.familyValue = "";
    this.isConnectedValue = false;

    // Dispatch Stimulus event
    this.dispatch('disconnected');
  }

  handleChainChanged(event) {
    // Update chain ID value
    this.chainIdValue = event.detail.connection.chainId;

    // Dispatch Stimulus event
    this.dispatch('chainChanged', {
      detail: { chainId: event.detail.connection.chainId }
    });
  }

  handleAccountChanged(event) {
    // Update address value
    this.addressValue = event.detail.connection.address;

    // Dispatch Stimulus event
    this.dispatch('accountChanged', {
      detail: { address: event.detail.connection.address }
    });
  }

  // ============================================================================
  // Value Change Callbacks (Stimulus Reactive Updates)
  // ============================================================================

  connectingValueChanged(isConnecting) {
    // Update loading state on selected wallet button
    if (this.hasModalTarget && this.selectedRdnsValue) {
      const button = this.modalTarget.querySelector(
        `[data-wallet-rdns="${this.selectedRdnsValue}"]`
      );
      if (button) {
        button.classList.toggle('loading', isConnecting);
      }
    }
  }

  isConnectedValueChanged(isConnected) {
    // Add/remove class to controller element for CSS targeting
    this.element.classList.toggle('wallet-connected', isConnected);
  }
}
